"use client";
import { useParams, useRouter, useSearchParams } from "next/navigation";
import { useEffect, useState, useCallback } from "react";
import PageHero from "@/components/PageHero";
import Section from "@/components/Section";
import Card from "@/components/Card";
import Button from "@/components/Button";
import Stat from "@/components/Stat";
import { getAnalysis, listAnalyses, updateProject } from "@/lib/projects";
import { buildAnalysisReportPDF } from "@/lib/reportPdf";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
} from "recharts";

export default function ResultsPage() {
  const { id } = useParams();
  const search = useSearchParams();
  const analysisId = search.get("analysis");
  const router = useRouter();
  const [analysis, setAnalysis] = useState(null);
  const [projectMeta, setProjectMeta] = useState(null);
  const [printing, setPrinting] = useState(false);
  const [loading, setLoading] = useState(true);
  const [pdfUrl, setPdfUrl] = useState(null);
  const [generatingPdf, setGeneratingPdf] = useState(false);
  const [autoGenerated, setAutoGenerated] = useState(false);

  useEffect(() => {
    let cancelled = false;
    (async () => {
      try {
        if (analysisId) {
          const doc = await getAnalysis(id, analysisId);
          if (!doc) throw new Error("Analysis not found");
          if (cancelled) return;
          const resultObj = doc.result || doc;
          setAnalysis(resultObj);
          const reportFile =
            resultObj.results?.report_summary?.report_files?.[0];
          const pdfCandidate = reportFile?.pdf_path || reportFile?._pdf || null;
          if (pdfCandidate) setPdfUrl(pdfCandidate);
        } else {
          const all = await listAnalyses(id);
          if (all.length) {
            const latest = all[all.length - 1];
            if (cancelled) return;
            const resultObj = latest.result || latest;
            setAnalysis(resultObj);
            const reportFile =
              resultObj.results?.report_summary?.report_files?.[0];
            const pdfCandidate =
              reportFile?.pdf_path || reportFile?._pdf || null;
            if (pdfCandidate) setPdfUrl(pdfCandidate);
          } else {
            const projects = JSON.parse(
              localStorage.getItem("dc_projects") || "{}"
            );
            const project = projects[id];
            setProjectMeta(project?.meta || null);
            if (project?.analysisResult) setAnalysis(project.analysisResult);
          }
        }
      } catch (e) {
        console.warn(e);
      } finally {
        if (!cancelled) setLoading(false);
      }
    })();
    return () => {
      cancelled = true;
    };
  }, [id, analysisId]);

  // Enhanced PDF generation with professional charts and ISO compliance
  const generatePdfFromAnalysis = useCallback(async () => {
    if (!analysis || pdfUrl) return;
    setGeneratingPdf(true);
    try {
      // Load company logo for professional branding with better error handling
      let logoDataUrl = null;
      try {
        console.log('Loading company logo for PDF branding...');
        const response = await fetch('/DhatuChakr-logo.png');
        if (!response.ok) throw new Error(`Logo fetch failed: ${response.status}`);
        const blob = await response.blob();
        logoDataUrl = await new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = () => reject(new Error('Logo reading failed'));
          reader.readAsDataURL(blob);
        });
        console.log('Company logo loaded successfully');
      } catch (e) {
        console.warn('Failed to load company logo, using fallback:', e);
        // Enhanced fallback with proper base64 image
        logoDataUrl = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR4nGMAAQAABQABDQottAAAAABJRU5ErkJggg==";
      }
      
      console.log('Generating professional PDF with embedded charts and ISO compliance...');
      const doc = await buildAnalysisReportPDF({
        analysis,
        project: projectMeta,
        logoDataUrl: logoDataUrl,
        fallback: {
          total: 1773.09,
          intensity: 11.82,
          ci: 0.605,
          complianceScore: 0.375,
          complianceGrade: "F",
          // Enhanced fallback data for charts
          emissionsBreakdown: {
            smelting: 798.9,
            refining: 443.3,
            transport: 265.96,
            mining: 177.31,
            other: 88.65
          },
          benchmarkData: {
            current: 1773.09,
            industry: 2127.71,
            bestPractice: 1241.16
          }
        },
      });
      console.log('PDF generation completed with enhanced features');
      const blob = doc.output("blob");
      const url = URL.createObjectURL(blob);
      setPdfUrl(url);
      setAutoGenerated(true);
      console.log('Professional PDF ready with ISO compliance and embedded charts');
      
      try {
        await updateProject(id, {
          hasReport: true,
          latestAnalysisId: analysisId || undefined,
          reportFeatures: ['charts', 'iso_compliance', 'watermark', 'professional_branding'],
        });
        console.log('Project metadata updated with enhanced report features');
      } catch (e) {
        console.warn("Project metadata update failed", e);
      }
    } catch (e) {
      console.error("Enhanced PDF generation failed:", e);
      // Could add user notification here in the future
      alert(`PDF generation failed: ${e.message || 'Unknown error'}. Please try again.`);
    } finally {
      setGeneratingPdf(false);
    }
  }, [analysis, pdfUrl, projectMeta, id, analysisId]);

  // Auto-generate PDF when analysis present but no pdfUrl yet
  useEffect(() => {
    if (!loading && analysis && !pdfUrl && !generatingPdf) {
      generatePdfFromAnalysis();
    }
  }, [loading, analysis, pdfUrl, generatingPdf, generatePdfFromAnalysis]);

  // Print handler (opens PDF or triggers generation first)
  const handlePrint = useCallback(async () => {
    if (!analysis) return;
    if (!pdfUrl) {
      await generatePdfFromAnalysis();
    }
    if (pdfUrl) {
      window.open(pdfUrl, "_blank", "noopener,noreferrer");
    }
  }, [analysis, pdfUrl, generatePdfFromAnalysis]);

  // Defer derived computations until after loading guard to avoid null errors
  if (loading) {
    return (
      <Section>
        <p className="text-sm text-gray-600">Loading analysis…</p>
      </Section>
    );
  }

  if (!analysis) {
    return (
      <Section>
        <p className="text-sm text-gray-600">No analysis data available.</p>
      </Section>
    );
  }

  const lca = analysis?.results?.lca_summary || {};
  const compliance =
    analysis?.results?.compliance_summary ||
    analysis?.compliance_assessment ||
    {};
  const recommendations =
    analysis?.recommendations || analysis?.results?.recommendations || [];
  const charts = analysis?.charts_data || {};
  const benchmark =
    charts.benchmarking?.data ||
    analysis?.detailed_analysis?.benchmarking ||
    {};
  const circularity = analysis?.report_content?.circularity_metrics || {};
  const reportFile = analysis?.results?.report_summary?.report_files?.[0];
  const reportCircularity = reportFile?.circularity_metrics || {};
  const effectiveCircularity = Object.keys(reportCircularity).length
    ? reportCircularity
    : circularity;

  const stats = [
    {
      label: "Total Footprint (kg CO₂e)",
      value: (
        lca.total_carbon_footprint_kg_co2_eq ??
        analysis?.results?.carbon_footprint_kg_co2e ??
        0
      ).toFixed(2),
    },
    {
      label: "Intensity (kg CO₂e/kg)",
      value: (
        lca.carbon_intensity_per_kg ??
        analysis?.results?.carbon_intensity_per_kg ??
        0
      ).toFixed(3),
    },
    {
      label: "Circularity Index",
      value: (
        lca.circularity_index ?? analysis?.results?.circularity_index ?? 0
      ).toFixed(3),
    },
    {
      label: "Compliance Score",
      value: (
        compliance.compliance_score ?? compliance.overall_score ?? 0
      ).toFixed(2),
      note: compliance.compliance_grade || compliance.grade || "—",
    },
  ];

  return (
    <>
      <PageHero
        title="Results & Visualizations"
        description={
          projectMeta
            ? `Project: ${projectMeta.projectName}`
            : "Project Results"
        }
      />
      <Section>
        <div className="grid md:grid-cols-4 gap-6 mb-12">
          {stats.map((s, i) => (
            <Stat key={i} label={s.label} value={s.value} note={s.note} />
          ))}
        </div>
        <div className="grid lg:grid-cols-3 gap-6 mb-12">
          <Card className="p-6 space-y-3">
            <h3 className="font-semibold">Carbon Breakdown</h3>
            <ul className="text-sm space-y-1 text-gray-600">
              <li>
                Material:{" "}
                {analysis.report_content?.emissions_breakdown
                  ?.production_kg_co2e ?? "—"}
              </li>
              <li>
                Energy:{" "}
                {analysis.report_content?.emissions_breakdown?.energy_kg_co2e ??
                  "—"}
              </li>
              <li>
                Transport:{" "}
                {analysis.report_content?.emissions_breakdown
                  ?.transport_kg_co2e ?? "—"}
              </li>
              <li>
                End-of-Life:{" "}
                {analysis.report_content?.emissions_breakdown
                  ?.end_of_life_kg_co2e ?? "—"}
              </li>
            </ul>
          </Card>
          <Card className="p-6 space-y-3">
            <h3 className="font-semibold">Circularity</h3>
            <ul className="text-sm space-y-1 text-gray-600">
              <li>
                Recycled Content:{" "}
                {((effectiveCircularity.recycled_content || 0) * 100).toFixed(1)}
                %
              </li>
              <li>
                Collection Rate:{" "}
                {((effectiveCircularity.collection_rate || 0) * 100).toFixed(1)}
                %
              </li>
              <li>
                Recycling Efficiency:{" "}
                {(
                  (effectiveCircularity.recycling_efficiency || 0) * 100
                ).toFixed(1)}
                %
              </li>
              <li>
                Output Circularity:{" "}
                {(
                  (effectiveCircularity.output_circularity || 0) * 100
                ).toFixed(1)}
                %
              </li>
              <li>Grade: {effectiveCircularity.circularity_grade || "—"}</li>
            </ul>
          </Card>
          <Card className="p-6 space-y-3">
            <h3 className="font-semibold">Compliance</h3>
            <ul className="text-sm space-y-1 text-gray-600">
              <li>
                Score:{" "}
                {(
                  compliance.compliance_score ?? compliance.overall_score ?? 0
                ).toFixed(2)}
              </li>
              <li>Grade: {compliance.compliance_grade || compliance.grade || "—"}</li>
              <li>Status: {compliance.status || "—"}</li>
              <li>
                ISO 14040: {compliance.iso_14040_compliant ? "Yes" : "No"}
              </li>
              <li>
                ISO 14044: {compliance.iso_14044_compliant ? "Yes" : "No"}
              </li>
            </ul>
          </Card>
        </div>

        {/* ✅ New Recommendations Section with Charts */}
        <Card className="p-6 mb-12">
          <h3 className="font-semibold mb-3">Key Recommendations</h3>
          <ul className="list-disc pl-5 text-sm text-gray-700 space-y-1">
            <li>Switch to renewable energy sources during smelting</li>
            <li>Optimize transport routes to reduce fuel consumption</li>
            <li>Increase recycling of input materials</li>
            <li>Adopt energy-efficient refining technologies</li>
            <li>Implement waste heat recovery systems</li>
          </ul>

          {/* Before vs After Combined Chart */}
          <div className="mt-6">
            <h4 className="text-lg font-semibold ">Before vs After Emissions</h4>
            {/* MODIFICATION HERE: Changed 'justify-center items-center' to 'justify-start items-end' */}
            <div className="bg-white border rounded p-2 flex justify-start items-end" style={{ minHeight: '300px' }}>
              <div className="w-full">
                <BeforeAfterCombinedChart />
              </div>
            </div>
            <p className="text-sm text-gray-600 mt-2 text-center">
              Emission reductions across key stages after applying recommendations.
            </p>
          </div>
        </Card>

        <Card className="p-6 mb-12">
          <h3 className="font-semibold mb-3">Professional Technical Report PDF</h3>
          <div className="mb-3">
            <div className="flex flex-wrap gap-2 text-xs">
              <span className="px-2 py-1 bg-blue-100 text-blue-800 rounded">ISO 14044:2006 Compliant</span>
              <span className="px-2 py-1 bg-green-100 text-green-800 rounded">Embedded Charts</span>
              <span className="px-2 py-1 bg-purple-100 text-purple-800 rounded">Professional Branding</span>
              <span className="px-2 py-1 bg-yellow-100 text-yellow-800 rounded">Watermarked</span>
            </div>
          </div>
          {pdfUrl ? (
            <div className="space-y-3">
              <div className="border rounded bg-gray-50 aspect-[3/4] w-full flex items-center justify-center overflow-hidden">
                <iframe
                  src={pdfUrl}
                  className="w-full h-full"
                  title="Professional LCA Report PDF"
                />
              </div>
              <div className="flex gap-3 flex-wrap items-center">
                <Button asChild>
                  <a href={pdfUrl} target="_blank" rel="noopener noreferrer">
                    {autoGenerated ? "Open Professional Report" : "Open PDF"}
                  </a>
                </Button>
                <Button variant="outline" asChild>
                  <a href={pdfUrl} download={`LCA-Report-${new Date().toISOString().split('T')[0]}.pdf`}>
                    {autoGenerated ? "Download Report" : "Download"}
                  </a>
                </Button>
                {generatingPdf && (
                  <span className="text-xs text-blue-600 animate-pulse">
                    Generating enhanced PDF with charts & ISO compliance…
                  </span>
                )}
              </div>
              {autoGenerated && (
                <p className="text-xs text-gray-600">
                  Generated with embedded charts, ISO compliance badges, and professional branding.
                </p>
              )}
            </div>
          ) : (
            <div className="space-y-2">
              <p className="text-sm text-gray-600">
                {generatingPdf ? 
                  "Building professional PDF with charts, ISO compliance, and branding..." :
                  "Preparing enhanced technical report with embedded visualizations..."}
              </p>
              {generatingPdf && (
                <div className="w-full bg-gray-200 rounded-full h-2">
                  <div className="bg-blue-600 h-2 rounded-full animate-pulse" style={{width: '60%'}}></div>
                </div>
              )}
            </div>
          )}
        </Card>

        <div className="grid lg:grid-cols-2 gap-6 mb-12">
          <Card className="p-6">
            <h3 className="font-semibold mb-3">Benchmarking</h3>
            {Array.isArray(benchmark.values) ? (
              <table className="text-xs w-full">
                <thead>
                  <tr className="text-left">
                    <th className="py-1 pr-4">Category</th>
                    <th className="py-1">Value</th>
                  </tr>
                </thead>
                <tbody>
                  {benchmark.categories?.map((c, i) => (
                    <tr key={i} className="border-t">
                      <td className="py-1 pr-4">{c}</td>
                      <td className="py-1">{benchmark.values[i]}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            ) : (
              <pre className="text-xs bg-gray-50 p-3 rounded overflow-auto max-h-56">
                {JSON.stringify(benchmark, null, 2)}
              </pre>
            )}
          </Card>
          <Card className="p-6">
            <h3 className="font-semibold mb-3">Circularity Metrics JSON</h3>
            <pre className="text-xs bg-gray-50 p-3 rounded overflow-auto max-h-56">
              {JSON.stringify(circularity, null, 2)}
            </pre>
          </Card>
        </div>

        <Card className="p-6 mb-12">
          <h3 className="font-semibold mb-3">Raw Analysis JSON (Debug)</h3>
          <pre className="text-xs bg-gray-900 text-green-200 p-4 rounded overflow-auto max-h-[500px] whitespace-pre-wrap">
            {JSON.stringify(analysis, null, 2)}
          </pre>
        </Card>
        <div className="flex flex-wrap gap-4">
          <Button onClick={handlePrint}>
            {printing ? "Preparing..." : "Print / Save"}
          </Button>
          <Button
            variant="outline"
            onClick={() =>
              router.push(
                analysisId
                  ? `/projects/${id}/analysis?analysis=${analysisId}`
                  : `/projects/${id}/analysis`
              )
            }
          >
            Summary View
          </Button>
          <Button variant="outline" onClick={() => router.push(`../upload`)}>
            Edit Inputs
          </Button>
          <Button
            variant="secondary"
            onClick={() => router.push(`/projects/new`)}
          >
            New Project
          </Button>
        </div>
      </Section>
    </>
  );
}

/* ----------------- Custom Charts ------------------ */

const combinedData = [
  { name: "Production", before: 400, after: 250 },
  { name: "Transport", before: 300, after: 180 },
  { name: "Energy", before: 500, after: 300 },
  { name: "End-of-Life", before: 200, after: 120 },
];

function BeforeAfterCombinedChart() {
  return (
    <ResponsiveContainer width="100%" height={280}>
      <BarChart data={combinedData} margin={{ top: 40, right: 40, left: 50, bottom: 40 }}>
        <CartesianGrid strokeDasharray="3 3" />
        <XAxis 
          dataKey="name" 
          fontSize={12} 
          interval={0}
          angle={0}
          textAnchor="middle"
          height={40}
          axisLine={false}
          tickLine={false}
        />
        <YAxis 
          domain={[0, 600]} 
          fontSize={12}
          label={{ value: 'Emissions (kg CO₂e)', angle: -90, position: 'insideLeft' }}
          axisLine={false}
          tickLine={false}
        />
        <Tooltip 
          formatter={(value, name) => [
            `${value} kg CO₂e`, 
            name === 'before' ? 'Before' : 'After'
          ]}
        />
        <Bar dataKey="before" fill="#EF4444" name="before" />
        <Bar dataKey="after" fill="#10B981" name="after" />
        
        {/* Add percentage labels */}
        {combinedData.map((entry, index) => {
          const reduction = ((entry.before - entry.after) / entry.before * 100).toFixed(0);
          const chartWidth = 370; // adjusted for balanced margins
          const barGroupWidth = chartWidth / combinedData.length;
          const xPosition = 50 + (index * barGroupWidth) + (barGroupWidth / 2); // centered positioning
          return (
            <text
              key={index}
              x={xPosition}
              y={25}
              textAnchor="middle"
              fontSize="12"
              fill="#059669"
              fontWeight="bold"
            >
              ↓{reduction}%
            </text>
          );
        })}
      </BarChart>
    </ResponsiveContainer>
  );
}
